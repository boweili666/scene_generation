<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Scene Graph Interface</title>

  <!-- Cytoscape.js -->
  <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>

  <style>
    * { box-sizing: border-box; font-family: Arial, Helvetica, sans-serif; }

    body {
      margin: 0;
      background: #f5f5f5;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .header {
      height: 60px;
      background: #1f2933;
      color: white;
      display: flex;
      align-items: center;
      padding: 0 20px;
      font-size: 20px;
      font-weight: bold;
    }

    .container {
      flex: 1;
      display: flex;
      padding: 12px;
      gap: 12px;
    }

    .conversation {
      flex: 1;
      background: white;
      border-radius: 8px;
      padding: 16px;
      display: flex;
      flex-direction: column;
    }

    .conversation h2,
    .panel h2 {
      margin-top: 0;
      font-size: 18px;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 8px;
    }

    .right-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .panel {
      flex: 1;
      background: white;
      border-radius: 8px;
      padding: 16px;
      display: flex;
      flex-direction: column;
    }

    textarea {
      flex: 1;
      resize: none;
      padding: 8px;
      font-size: 20px;
      border-radius: 6px;
      border: 1px solid #cbd5e1;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    button {
      padding: 8px 14px;
      font-size: 14px;
      border-radius: 6px;
      border: none;
      background: #2563eb;
      color: white;
      cursor: pointer;
    }

    .status {
      font-size: 13px;
      color: #475569;
    }

    .placeholder {
      flex: 1;
      border: 1px dashed #cbd5e1;
      border-radius: 6px;
      position: relative;
      overflow: hidden;
    }

    .json-output {
      background: #0f172a;
      color: #e2e8f0;
      padding: 12px;
      border-radius: 6px;
      font-family: "SFMono-Regular", Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      max-height: 220px;
      overflow: auto;
      white-space: pre-wrap;
    }

    #sceneGraph {
      width: 100%;
      height: 100%;
    }

    .placeholder img {
      max-width: 100%;
      max-height: 100%;
      display: none;
    }
  </style>
</head>

<body>
  <div class="header">Scene Graph Generation & Visualization</div>

  <div class="container">

    <!-- Left: Conversation -->
    <div class="conversation">
      <h2>Conversation</h2>

      <textarea
        id="sceneInput"
        placeholder="Describe the scene in natural language..."
      ></textarea>

      <div class="controls" style="margin-top:8px;">
        <input id="imageInput" type="file" accept="image/*" />
        <span class="status" id="uploadStatus">Image optional</span>
      </div>

      <div class="controls" style="margin-top:8px;">
        <label style="font-size:13px;">Or pick a folder locally:</label>
        <input id="classDirPicker" type="file" webkitdirectory multiple />
        <span class="status" id="classStatus"></span>
      </div>

      <button
        style="margin-top:10px;"
        onclick="generateSceneGraph()"
      >
        Generate Scene Graph
      </button>

      <button
        id="editJsonFromConversationBtn"
        style="margin-top:8px; background:#0ea5e9;"
        onclick="editJsonFromConversation()"
      >
        Edit JSON with Left Description
      </button>

      <div class="controls" style="margin-top:6px; justify-content: space-between; align-items: center;">
        <span class="status" id="jsonStatus">Idle</span>
      </div>
      <div class="json-output" id="jsonPreview" aria-live="polite">Waiting for GPT JSON result...</div>
    </div>

    <!-- Right -->
    <div class="right-panel">

      <!-- Scene Graph -->
      <div class="panel">
        <h2>Scene Graph Visualization</h2>
        <div class="placeholder">
          <div id="sceneGraph"></div>
        </div>
      </div>

      <!-- Isaac Sim / Scene Service -->
      <div class="panel">
        <h2>Isaac Sim & Scene Service</h2>

        <div class="controls" style="flex-wrap: wrap; gap: 8px 12px;">
          <button id="generateBtn" onclick="generateScene()">Generate Scene</button>
          <button id="real2simBtn" onclick="runReal2Sim()">Real2Sim</button>
          <button onclick="callSceneService('scene')">POST /scene</button>
          <button onclick="callSceneService('scene_new')">POST /scene_new</button>
          <span id="status" class="status">Idle</span>
          <span id="sceneSvcStatus" class="status">Idle</span>
        </div>

        <div class="placeholder">
          <img id="renderImage" src="assets/renders/render.png" />
          <span id="imagePlaceholder">No image yet</span>
        </div>

        <div class="json-output" id="sceneSvcResult">Waiting for response...</div>
      </div>

    </div>
  </div>

  <script>
    let cy = null;

    /* ========= Render Scene Graph ========= */
    function renderSceneGraph(graph) {
      const elements = [];

      for (const obj of graph.objects) {
        elements.push({
          data: {
            id: obj.path,
            label: obj.class_name
          }
        });
      }

      for (const e of graph.edges) {
        elements.push({
          data: {
            id: e.source + "->" + e.target,
            source: e.source,
            target: e.target,
            label: e.relation
          }
        });
      }

      if (cy) cy.destroy();

      cy = cytoscape({
        container: document.getElementById("sceneGraph"),
        elements: elements,
        style: [
          {
            selector: "node",
            style: {
              "background-color": "#2563eb",
              "label": "data(label)",
              "color": "white",
              "text-valign": "center",
              "shape": "round-rectangle",
              "padding": "8px",
              "font-size": "12px"
            }
          },
          {
            selector: "edge",
            style: {
              "curve-style": "bezier",
              "target-arrow-shape": "triangle",
              "label": "data(label)",
              "font-size": "10px",
              "text-background-color": "white",
              "text-background-opacity": 1,
              "text-background-padding": "2px"
            }
          }
        ],
        layout: {
          name: "cose",
          animate: true,
          padding: 30
        }
      });
    }

    /* ========= Load initial graph from file ========= */
    async function loadSceneGraph() {
      const res = await fetch("/scene_graph");
      const graph = await res.json();
      renderSceneGraph(graph);
    }

    /* ========= Text or Image â†’ Scene Graph ========= */
    async function generateSceneGraph() {
      const text = document.getElementById("sceneInput").value;
      const fileInput = document.getElementById("imageInput");
      const uploadStatus = document.getElementById("uploadStatus");
      const classDirPicker = document.getElementById("classDirPicker");
      const classStatus = document.getElementById("classStatus");

      const formData = new FormData();
      if (text.trim()) formData.append("text", text);
      if (fileInput.files.length > 0) {
        formData.append("image", fileInput.files[0]);
        uploadStatus.textContent = "Using uploaded image";
      } else {
        uploadStatus.textContent = "Using text description";
      }
      if (classDirPicker.files.length > 0) {
        const names = Array.from(classDirPicker.files)
          .map((f) => {
            const parts = f.name.split(".");
            parts.pop();
            return parts.join("."); // drop extension
          })
          .filter(Boolean);
        formData.append("class_names", JSON.stringify(names));
        classStatus.textContent = `${names.length} file names added`;
      } else {
        classStatus.textContent = "";
      }

      try {
        const res = await fetch("/scene_from_input", {
          method: "POST",
          body: formData
        });

        const graph = await res.json();
        if (!res.ok) {
          alert(graph.error || "Generation failed");
          return;
        }
        renderSceneGraph(graph);
      } catch (err) {
        console.error(err);
        alert("Failed to generate scene graph");
      }
    }

    /* ========= Isaac Sim ========= */
    async function generateScene() {
      const btn = document.getElementById("generateBtn");
      const status = document.getElementById("status");
      const img = document.getElementById("renderImage");
      const placeholder = document.getElementById("imagePlaceholder");

      btn.disabled = true;
      status.textContent = "Generating scene...";

      try {
        await fetch("/generate");
        img.src = "assets/renders/render.png?ts=" + Date.now();
        img.style.display = "block";
        placeholder.style.display = "none";
        status.textContent = "Done";
      } catch (err) {
        console.error(err);
        status.textContent = "Failed";
      }

      btn.disabled = false;
    }

    /* ========= Real2Sim Pipeline ========= */
    async function runReal2Sim() {
      const btn = document.getElementById("real2simBtn");
      const status = document.getElementById("status");
      const img = document.getElementById("renderImage");
      const placeholder = document.getElementById("imagePlaceholder");

      btn.disabled = true;
      status.textContent = "Running Real2Sim...";

      try {
        const res = await fetch("/real2sim");
        const data = await res.json();
        if (!res.ok) {
          status.textContent = "Failed";
          alert((data && (data.detail || data.msg)) || "Real2Sim failed");
          btn.disabled = false;
          return;
        }
        img.src = "assets/renders/render.png?ts=" + Date.now();
        img.style.display = "block";
        placeholder.style.display = "none";
        status.textContent = "Done";
      } catch (err) {
        console.error(err);
        status.textContent = "Failed";
      }

      btn.disabled = false;
    }

    /* ========= Isaac Scene Service (FastAPI) ========= */
    async function callSceneService(endpoint) {
      const statusEl = document.getElementById("sceneSvcStatus");
      const resultEl = document.getElementById("sceneSvcResult");
      const img = document.getElementById("renderImage");
      const placeholder = document.getElementById("imagePlaceholder");

      const base = "http://127.0.0.1:8001";
      const payload = {}; // Fixed command, empty JSON

      statusEl.textContent = `Calling /${endpoint} ...`;
      resultEl.textContent = "Requesting...";

      try {
        const res = await fetch(`${base}/${endpoint}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        const data = await res.json();
        statusEl.textContent = res.ok ? "Done" : "Failed";
        resultEl.textContent = JSON.stringify(data, null, 2);
        if (!res.ok) {
          alert(data.detail || data.error || "Request failed");
        } else {
          // Refresh render.png
          img.src = "assets/renders/render.png?ts=" + Date.now();
          img.style.display = "block";
          placeholder.style.display = "none";
        }
      } catch (err) {
        console.error(err);
        statusEl.textContent = "Failed";
        resultEl.textContent = String(err);
        alert("Request failed, possibly a port or CORS issue");
      }
    }

    /* ========= GPT JSON Editing ========= */
    async function editJson(opts = {}) {
      const status = document.getElementById("jsonStatus");
      const preview = document.getElementById("jsonPreview");
      const triggerBtn = opts.btn || null;
      const instruction =
        (opts.instruction && opts.instruction.trim()) ||
        document.getElementById("sceneInput").value.trim(); // Directly use the left description

      if (!instruction) {
        alert("Please enter a description on the left first");
        return;
      }

      if (triggerBtn) triggerBtn.disabled = true;
      status.textContent = "Calling...";
      preview.textContent = "Waiting for GPT response...";

      try {
        const res = await fetch("/edit_json", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ instruction }),
        });

        const data = await res.json();
        if (!res.ok) {
          const msg = data.error || data.detail || "Edit failed";
          status.textContent = "Failed";
          preview.textContent = msg;
          alert(msg);
          if (triggerBtn) triggerBtn.disabled = false;
          return;
        }

        status.textContent = "Done";
        const pretty = JSON.stringify(data.json, null, 2);
        preview.textContent = `Input: ${data.input}\nOutput: ${data.output}\n\n${pretty}`;
      } catch (err) {
        console.error(err);
        status.textContent = "Failed";
        preview.textContent = "Request failed";
        alert("Request failed");
      }

      if (triggerBtn) triggerBtn.disabled = false;
    }

    // Use left conversation text to call GPT JSON edit
    function editJsonFromConversation() {
      const sceneText = document.getElementById("sceneInput").value.trim();
      if (!sceneText) {
        alert("Please enter a description on the left first");
        return;
      }
      editJson({ instruction: sceneText, btn: document.getElementById("editJsonFromConversationBtn") });
    }

    // Load Scene Graph file initially
    loadSceneGraph();
  </script>
</body>
</html>
